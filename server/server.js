const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { ApifyClient } = require('apify-client');
const createCsvWriter = require('csv-writer').createObjectCsvWriter;
const path = require('path');
const fs = require('fs');
const os = require('os');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware b·∫£o m·∫≠t
app.use(helmet());

// CORS configuration
const corsOptions = {
    origin: function (origin, callback) {
        // Cho ph√©p requests kh√¥ng c√≥ origin (mobile apps, Postman, etc.)
        if (!origin) return callback(null, true);

        const allowedOrigins = [
            'http://localhost:3000',
            'https://localhost:3000',
            'https://facebook-comment-extractor.vercel.app',
            'https://facebook-comment-extractor-production.up.railway.app'
        ];

        // Cho ph√©p domain Vercel v√† Railway v·ªõi subdomain b·∫•t k·ª≥
        const isDevelopment = process.env.NODE_ENV !== 'production';
        const isVercelDomain = origin.includes('.vercel.app');
        const isRailwayDomain = origin.includes('.railway.app');

        if (isDevelopment || allowedOrigins.includes(origin) || isVercelDomain || isRailwayDomain) {
            return callback(null, true);
        }

        return callback(new Error('Kh√¥ng ƒë∆∞·ª£c ph√©p b·ªüi CORS'), false);
    },
    credentials: true,
    optionsSuccessStatus: 200
};

app.use(cors(corsOptions));
app.use(express.json());

// Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 ph√∫t
    max: 10, // Gi·ªõi h·∫°n 10 requests m·ªói 15 ph√∫t
    message: 'Qu√° nhi·ªÅu y√™u c·∫ßu, vui l√≤ng th·ª≠ l·∫°i sau 15 ph√∫t.'
});
app.use('/api/extract', limiter);

// T·∫°o th∆∞ m·ª•c downloads n·∫øu ch∆∞a c√≥
const downloadsDir = path.join(__dirname, 'downloads');
try {
    if (!fs.existsSync(downloadsDir)) {
        fs.mkdirSync(downloadsDir, { recursive: true });
        console.log('‚úÖ ƒê√£ t·∫°o th∆∞ m·ª•c downloads');
    }
} catch (error) {
    console.error('‚ö†Ô∏è  Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c downloads:', error.message);
    // S·ª≠ d·ª•ng th∆∞ m·ª•c t·∫°m th·ªùi c·ªßa h·ªá th·ªëng
    const downloadsDir = os.tmpdir();
    console.log('üìÅ S·ª≠ d·ª•ng th∆∞ m·ª•c t·∫°m th·ªùi:', downloadsDir);
}

// API endpoint ƒë·ªÉ tr√≠ch xu·∫•t b√¨nh lu·∫≠n
app.post('/api/extract', async (req, res) => {
    // TƒÉng timeout cho request d√†i - 15 ph√∫t cho posts c√≥ nhi·ªÅu comment
    req.setTimeout(900000); // 15 ph√∫t
    res.setTimeout(900000);

    try {
        const { token, url, maxComments = 100 } = req.body;

        // Validate input
        if (!token) {
            return res.status(400).json({
                success: false,
                message: 'Token API Apify l√† b·∫Øt bu·ªôc'
            });
        }

        if (!url) {
            return res.status(400).json({
                success: false,
                message: 'URL b√†i ƒëƒÉng Facebook l√† b·∫Øt bu·ªôc'
            });
        }

        // Ki·ªÉm tra URL c√≥ ph·∫£i Facebook kh√¥ng
        if (!url.includes('facebook.com')) {
            return res.status(400).json({
                success: false,
                message: 'URL ph·∫£i l√† ƒë∆∞·ªùng link Facebook h·ª£p l·ªá'
            });
        }

        // Kh·ªüi t·∫°o Apify client v·ªõi timeout d√†i h∆°n
        const client = new ApifyClient({
            token,
            requestOptions: {
                timeout: 900000 // 15 ph√∫t
            }
        });

        // C·∫•u h√¨nh input cho scraper v·ªõi timeout settings
        const runInput = {
            startUrls: [{ url }],
            resultsLimit: parseInt(maxComments),
            includeNestedComments: true,
            viewOption: "RANKED_UNFILTERED",
            // Th√™m timeout cho Apify actor
            timeoutSecs: 900 // 15 ph√∫t
        };

        // Ch·∫°y actor v·ªõi monitoring
        console.log('B·∫Øt ƒë·∫ßu tr√≠ch xu·∫•t b√¨nh lu·∫≠n...');
        console.log('Max comments:', maxComments);
        console.log('Run input:', JSON.stringify(runInput, null, 2));

        const run = await client.actor("apify/facebook-comments-scraper").call(runInput, {
            // Ch·ªù actor ho√†n th√†nh v·ªõi timeout d√†i h∆°n
            waitSecs: 900 // 15 ph√∫t
        });

        console.log('Run completed:', run.id);
        console.log('Run status:', run.status);

        // L·∫•y d·ªØ li·ªáu t·ª´ dataset v·ªõi retry mechanism
        console.log('L·∫•y d·ªØ li·ªáu t·ª´ dataset...');
        const datasetItems = [];

        try {
            // S·ª≠ d·ª•ng c√°ch ƒë√∫ng ƒë·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ Apify dataset v·ªõi chunking
            const dataset = client.dataset(run.defaultDatasetId);

            // L·∫•y d·ªØ li·ªáu theo batch ƒë·ªÉ tr√°nh timeout
            let offset = 0;
            const limit = 1000; // L·∫•y 1000 items m·ªói l·∫ßn
            let hasMore = true;

            while (hasMore) {
                console.log(`ƒêang l·∫•y batch ${Math.floor(offset / limit) + 1}...`);
                const { items } = await dataset.listItems({
                    offset,
                    limit
                });

                if (items.length === 0) {
                    hasMore = false;
                } else {
                    datasetItems.push(...items);
                    offset += items.length;

                    // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng comment theo maxComments
                    if (datasetItems.length >= parseInt(maxComments)) {
                        datasetItems.splice(parseInt(maxComments));
                        hasMore = false;
                    }
                }

                // Log progress
                console.log(`ƒê√£ l·∫•y ${datasetItems.length} comments...`);
            }

        } catch (datasetError) {
            console.error('L·ªói khi l·∫•y d·ªØ li·ªáu t·ª´ dataset:', datasetError);
            throw new Error('Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ dataset: ' + datasetError.message);
        }

        if (datasetItems.length === 0) {
            return res.json({
                success: false,
                message: 'Kh√¥ng t√¨m th·∫•y b√¨nh lu·∫≠n n√†o. C√≥ th·ªÉ b√†i ƒëƒÉng kh√¥ng c√≥ comment ho·∫∑c ƒë√£ b·ªã ·∫©n.'
            });
        }

        // T·∫°o file CSV
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0] + '_' +
            new Date().toTimeString().split(' ')[0].replace(/:/g, '');
        const filename = `facebook_comments_${timestamp}.csv`;
        const filepath = path.join(downloadsDir, filename);

        const csvWriter = createCsvWriter({
            path: filepath,
            header: [
                { id: 'commentUrl', title: 'Comment URL' },
                { id: 'date', title: 'Ng√†y' },
                { id: 'facebookId', title: 'Facebook ID' },
                { id: 'facebookUrl', title: 'Facebook URL' },
                { id: 'feedbackId', title: 'Feedback ID' },
                { id: 'id', title: 'ID' },
                { id: 'inputUrl', title: 'Input URL' },
                { id: 'likesCount', title: 'L∆∞·ª£t th√≠ch' },
                { id: 'pageAdLibraryId', title: 'Page Ad Library ID' },
                { id: 'pageAdLibraryActive', title: 'Page Active' },
                { id: 'postTitle', title: 'Ti√™u ƒë·ªÅ b√†i ƒëƒÉng' },
                { id: 'profileId', title: 'Profile ID' },
                { id: 'profileName', title: 'T√™n profile' },
                { id: 'profilePicture', title: '·∫¢nh ƒë·∫°i di·ªán' },
                { id: 'profileUrl', title: 'Profile URL' },
                { id: 'text', title: 'N·ªôi dung b√¨nh lu·∫≠n' },
                { id: 'threadingDepth', title: 'ƒê·ªô s√¢u thread' }
            ]
        });

        // Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ ghi v√†o CSV
        const csvData = datasetItems.map(item => ({
            commentUrl: item.commentUrl || '',
            date: item.date || '',
            facebookId: item.facebookId || '',
            facebookUrl: item.facebookUrl || '',
            feedbackId: item.feedbackId || '',
            id: item.id || '',
            inputUrl: item.inputUrl || '',
            likesCount: item.likesCount || '',
            pageAdLibraryId: item.pageAdLibrary?.id || '',
            pageAdLibraryActive: item.pageAdLibrary?.is_business_page_active || '',
            postTitle: item.postTitle || '',
            profileId: item.profileId || '',
            profileName: item.profileName || '',
            profilePicture: item.profilePicture || '',
            profileUrl: item.profileUrl || '',
            text: item.text || '',
            threadingDepth: item.threadingDepth || ''
        }));

        await csvWriter.writeRecords(csvData);

        res.json({
            success: true,
            message: `ƒê√£ tr√≠ch xu·∫•t th√†nh c√¥ng ${datasetItems.length} b√¨nh lu·∫≠n`,
            count: datasetItems.length,
            filename: filename,
            downloadUrl: `/api/download/${filename}`
        });

    } catch (error) {
        console.error('L·ªói tr√≠ch xu·∫•t:', error);

        let statusCode = 500;
        let errorMessage = 'C√≥ l·ªói x·∫£y ra khi tr√≠ch xu·∫•t b√¨nh lu·∫≠n';

        // Handle specific Apify errors
        if (error.message.includes('timeout') || error.code === 'ECONNABORTED') {
            statusCode = 504;
            errorMessage = 'Qu√° tr√¨nh tr√≠ch xu·∫•t m·∫•t qu√° nhi·ªÅu th·ªùi gian. H√£y th·ª≠ gi·∫£m s·ªë l∆∞·ª£ng comment ho·∫∑c th·ª≠ l·∫°i sau.';
        } else if (error.message.includes('Actor run') && error.message.includes('failed')) {
            statusCode = 422;
            errorMessage = 'Kh√¥ng th·ªÉ tr√≠ch xu·∫•t t·ª´ URL n√†y. Vui l√≤ng ki·ªÉm tra URL c√≥ ƒë√∫ng v√† c√¥ng khai kh√¥ng.';
        } else if (error.message.includes('dataset')) {
            statusCode = 503;
            errorMessage = 'C√≥ l·ªói khi l·∫•y d·ªØ li·ªáu. H√£y th·ª≠ l·∫°i sau v√†i ph√∫t.';
        } else if (error.message.includes('token')) {
            statusCode = 401;
            errorMessage = 'Token API kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.';
        }

        // Add specific guidance for large comment extraction
        if (req.body.maxComments > 1000) {
            errorMessage += '\n\nƒê·ªëi v·ªõi posts c√≥ nhi·ªÅu comment (>1000), h√£y:\n1. Th·ª≠ gi·∫£m s·ªë l∆∞·ª£ng comment\n2. ƒê·∫£m b·∫£o post l√† c√¥ng khai\n3. Th·ª≠ l·∫°i v√†o th·ªùi ƒëi·ªÉm kh√°c';
        }

        res.status(statusCode).json({
            success: false,
            message: errorMessage,
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
});

// API endpoint ƒë·ªÉ t·∫£i file
app.get('/api/download/:filename', (req, res) => {
    const filename = req.params.filename;
    const filepath = path.join(downloadsDir, filename);

    if (fs.existsSync(filepath)) {
        res.download(filepath, filename);
    } else {
        res.status(404).json({
            success: false,
            message: 'File kh√¥ng t·ªìn t·∫°i'
        });
    }
});

// Health check endpoint
app.get('/api/health', (req, res) => {
    res.status(200).json({
        status: 'OK',
        message: 'Server ƒëang ho·∫°t ƒë·ªông',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        environment: process.env.NODE_ENV || 'development',
        version: require('./package.json').version
    });
});

app.listen(PORT, () => {
    console.log(`üöÄ Server ƒëang ch·∫°y tr√™n port ${PORT}`);
    console.log(`üìÅ Th∆∞ m·ª•c downloads: ${downloadsDir}`);
    console.log(`üåç Environment: ${process.env.NODE_ENV || 'development'}`);
    console.log(`‚öôÔ∏è  CORS origins configured for production`);
});

// Global error handler
app.use((error, req, res, next) => {
    console.error('Global error handler:', error);
    res.status(500).json({
        success: false,
        message: 'L·ªói server n·ªôi b·ªô',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
});

module.exports = app; 